# ==============================================================================
# Dockerfile - 後端 Flask 應用程式容器化配置
# ==============================================================================
# 這個檔案定義如何將 Flask 應用程式打包成 Docker 容器
# Docker 會依照這個檔案的指令，一層一層建立映像 (image)
# ==============================================================================

# ------------------------------------------------------------------------------
# 第一層：基礎映像 (Base Image)
# ------------------------------------------------------------------------------
# FROM: 指定基礎映像，所有 Dockerfile 的第一行必須是 FROM
# python:3.12-slim: Python 官方映像的精簡版
#   - slim 版本約 150MB，完整版約 1GB
#   - 包含 Python 執行環境，但移除了不必要的套件
FROM python:3.12-slim

# ------------------------------------------------------------------------------
# 第二層：設定工作目錄
# ------------------------------------------------------------------------------
# WORKDIR: 設定容器內的工作目錄
#   - 之後的所有指令 (COPY, RUN, CMD) 都會在這個目錄執行
#   - /app 是容器內的路徑，不是您電腦的路徑
#   - 如果目錄不存在，會自動建立
WORKDIR /app

# ------------------------------------------------------------------------------
# 第三層：安裝系統依賴
# ------------------------------------------------------------------------------
# RUN: 執行 shell 指令，結果會被儲存為新的一層
#
# apt-get update: 更新套件索引（必須先執行才能 install）
# apt-get install -y: 安裝套件
#   - -y: 自動確認所有提示，避免互動式安裝卡住
#   - \: 換行符號，讓長指令更易讀
#
# 安裝的套件說明：
#   - gcc: C 編譯器，編譯某些 Python 套件需要（如 psycopg2）
#   - libpq-dev: PostgreSQL 連線庫的開發檔案（psycopg2 需要）
#   - python3-dev: Python 開發標頭檔，編譯 C 擴展模組需要
#
# rm -rf /var/lib/apt/lists/*: 清除 apt 快取
#   - /var/lib/apt/lists/ 存放套件索引，安裝完就不需要了
#   - 刪除可減少映像大小約 20-50MB
#   - 這是 Docker 最佳實踐
RUN apt-get update && apt-get install -y \
    gcc \
    libpq-dev \
    python3-dev \
    && rm -rf /var/lib/apt/lists/*

# ------------------------------------------------------------------------------
# 第四層：安裝 Python 依賴
# ------------------------------------------------------------------------------
# COPY requirements.txt .: 只先複製 requirements.txt 到容器
#   - 第一個參數: 本地檔案路徑（相對於 Dockerfile）
#   - 第二個參數: 容器內路徑（. 表示 WORKDIR，即 /app）
#
# 💡 Docker 快取機制：
#   - Docker 會快取每一層的建置結果
#   - 如果某一層的內容沒變，就會使用快取
#   - 把 requirements.txt 分開複製的好處：
#     如果程式碼改了，但 requirements.txt 沒變
#     就不需要重新執行 pip install，大幅加速建置！
COPY requirements.txt .

# pip install: 安裝 Python 套件
#   - --no-cache-dir: 不儲存 pip 快取，減少映像大小
#   - -r requirements.txt: 從檔案讀取套件清單
RUN pip install --no-cache-dir -r requirements.txt

# ------------------------------------------------------------------------------
# 第五層：複製應用程式碼
# ------------------------------------------------------------------------------
# COPY . .: 複製當前目錄的所有檔案到容器的 /app
#   - 第一個 .: 本地的當前目錄（Dockerfile 所在目錄）
#   - 第二個 .: 容器的工作目錄（/app）
#   - 會忽略 .dockerignore 中列出的檔案
#
# 注意：這一層放在最後，因為程式碼最常變動
#       這樣改程式碼時，前面的層都可以使用快取
COPY . .

# ------------------------------------------------------------------------------
# 第六層：環境變數設定
# ------------------------------------------------------------------------------
# ENV: 設定容器內的環境變數
#   - 這些變數在容器運行時都可以存取
#   - 也可以被 docker run -e 覆蓋
#
# FLASK_APP: 告訴 Flask 主程式檔案的位置
# FLASK_ENV: 執行環境
#   - production: 生產模式，關閉 debug，優化效能
#   - development: 開發模式，啟用 debug 和自動重載
ENV FLASK_APP=app.py
ENV FLASK_ENV=production

# ------------------------------------------------------------------------------
# 第七層：宣告 Port
# ------------------------------------------------------------------------------
# EXPOSE: 宣告容器會使用的 port
#   - 這是文件性質的宣告，不會真的開啟 port
#   - 真正開啟 port 是在 docker run -p 時
#   - 但這讓其他人知道這個容器需要 5000 port
EXPOSE 5000

# ------------------------------------------------------------------------------
# 啟動指令
# ------------------------------------------------------------------------------
# CMD: 容器啟動時執行的預設指令
#   - 使用 JSON 陣列格式（exec form），推薦用法
#   - 與 RUN 不同：RUN 在建置時執行，CMD 在容器啟動時執行
#
# gunicorn: 生產級 WSGI 伺服器
#   - 比 Flask 內建的開發伺服器效能好、更穩定
#   - WSGI = Web Server Gateway Interface，Python Web 應用的標準介面
#
# 參數說明：
#   --bind 0.0.0.0:5000: 監聽的地址和 port
#     - 0.0.0.0 表示監聯所有網路介面（不只是 localhost）
#     - 5000 是 port 號
#   --workers 2: 啟動 2 個工作程序
#     - 可以同時處理多個請求
#     - 建議值：(2 x CPU核心數) + 1
#   --timeout 120: 請求超時時間（秒）
#     - 如果一個請求處理超過 120 秒，會被強制終止
#   app:app: 應用程式位置
#     - 第一個 app: 檔案名稱（app.py）
#     - 第二個 app: Flask 應用程式變數名稱
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "2", "--timeout", "120", "app:app"]